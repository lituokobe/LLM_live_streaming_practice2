[{"bbox": [121, 98, 1608, 1336], "category": "Text", "text": "```groovy\n.setBootstrapServers(\"node1:9092,node2:9092,node3:9092\") //设置Kafka集群Brokers\n.setTopics(\"testtopic\") //设置topic\n.set GROUPId(\"my-test-group\") //设置消费者组\n.setStartingOffsets(OffsetsInitializer.latest()) // 读取位置\n.setDeserializer(new KafkaRecordDeserializationSchema[(String, String)]) {\n    //组织 consumerRecord 数据\n    override def deserialze(consumerRecord: ConsumerRecord[IArray[Byte], IArray[Byte]], collector: Collector[(S\n        var key: String = null\n        var value: String = null\n        if (consumerRecord.key() != null) {\n            key = new String(consumerRecord.key(), \"UTF-8\")\n        }\n        if (consumerRecord.value() != null) {\n            value = new String(consumerRecord.value(), \"UTF-8\")\n        }\n        collector.collect((key, value))\n    }\n\n//设置返回的二元组类型,createTuple2TypeInformation 需要导入隐式转换\noverride def getProducedType: TypeInformation[(String, String)] = {\n    createTuple2TypeInformation(createTypeInformation String, createTypeInformation String)]\n}\n}\n.build()\n\nval ds: DataStream[(String, String)] = env.fromSource(kafkaSource, WatermarkStrategy.noWatermarks(), \"kafka\nds.print()\nenv.execute()\n```"}, {"bbox": [107, 1378, 1584, 1531], "category": "Text", "text": "代码编写完成后执行,向kafka testtopic中输入如下key, value数据,需要在kafka命令中加入\n\"parse.key”、“key_SEPARATOR”配置项分别指定向kafka topic中生产数据带有key和kv数据的分\n隔符(默认是\\t),可以在控制台看到key、value对应数据结果。"}, {"bbox": [121, 1575, 1604, 1836], "category": "Text", "text": "```\n[root@node1 bin]# kafka-console-producer.sh --bootstrap-server node1:9092,node2:9092,node3:9092 --top\n> key1|value1\n> key2|value2\n> key3|value3\n> key4|value4\n> key5|value5\n```"}, {"bbox": [110, 1896, 541, 1957], "category": "Title", "text": "### 6.3.5 自定义 Source"}, {"bbox": [108, 1989, 1563, 2088], "category": "Text", "text": "对于一些其他的数据源,我们也可以实现自定义Source进行实时数据获取。自定义数据源有两种实现方式:"}]