[{"bbox": [108, 99, 1590, 302], "category": "Text", "text": "使用rescale时,建议下游算子并行度是上游算子并行度的整数倍,这样效率比较高。例如:如果上游操作的并行度为2,下游操作的并行度为6,那么一个上游操作将将元素分发给三个下游操作,而另一个上游操作将分发给其他三个下游操作。如果上下游算子并行度不是整数倍就会存在上游算子并行度向下游分发数据分发的并行度不同,如下图所示:"}, {"bbox": [128, 393, 1570, 1323], "category": "Picture"}, {"bbox": [132, 1379, 390, 1427], "category": "Title", "text": "## Java代码实现"}, {"bbox": [123, 1472, 1510, 2074], "category": "Text", "text": "```java\nStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\nenv.setParallelism(2);\nDataStreamSource<Object> ds = env.addSource(new RichParallelSourceFunction<Object>() {\n    @Override\n    public void run(SourceContext<Object> ctx) throws Exception {\n        List<String> list1 = Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n        List<Integer> list2 = Arrays.asList(1, 2, 3, 4, 5, 6);\n        for (String elem : list1) {\n            //这里的getRuntimeContext().getIndexOfThisSubtask()是获取当前subtask的index,从0开始\n            if (0 == getRuntimeContext().getIndexOfThisSubtask()) {\n                ctx.collect(elem);\n            }\n        }\n        for (Integer elem : list2) {\n```"}]