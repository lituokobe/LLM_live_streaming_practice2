[{"bbox": [108, 100, 1591, 200], "category": "Text", "text": "在Flink中可以对oriDataStream调用KeyBy方法来使用hash partitioner,该方法需要指定一个key,对该key进行hash计算然后与下游task个数取模来决定数据应该被下游哪些分区task处理。"}, {"bbox": [110, 234, 772, 285], "category": "Text", "text": "keyBy具体代码参考6.4小节KeyBy算子操作。"}, {"bbox": [110, 331, 571, 394], "category": "Title", "text": "## 6.7.2 shuffle随机分区"}, {"bbox": [110, 426, 1583, 573], "category": "Text", "text": "在Flink中可以对oriDataStream调用shuffle方法来使用shuffle partitioner分区策略对数据进行随机分区,将数据随机分配到下游算子每个分区中,shuffle方法不会改变oriDataStream类型。可以在增大分区,或者出现数据倾斜的场景中使用该方式对数据进行随机分区。"}, {"bbox": [126, 671, 1564, 1014], "category": "Picture"}, {"bbox": [108, 1058, 1583, 1326], "category": "Text", "text": "**注意:**\n1) 由于是随机分区,每次执行shuffle操作后,下游每个分区中的数据也会不同。\n2) shuffle partitioner分区策略会将上游一个并行度数据全局打散随机分发到下游分区中,网络开销大。"}, {"bbox": [126, 1358, 392, 1408], "category": "Text", "text": "* **Java代码实现**"}, {"bbox": [124, 1455, 1411, 1667], "category": "Text", "text": "StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\nenv.setParallelism(1);\noriDataStream&lt;String&gt; source = env.socketTextStream(\"node5\", 9999);\nsource shuffler().print(\"shuffle\").setParallelism(3);\nenv.execute();"}, {"bbox": [130, 1716, 404, 1765], "category": "Text", "text": "* **Scala代码实现**"}, {"bbox": [124, 1814, 1439, 2028], "category": "Text", "text": "val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment\n//设置并行度为1\nenv.setParallelism(1)\nval ds: DataStream-[String] = env.socketTextStream(\"node5\", 9999)"}]