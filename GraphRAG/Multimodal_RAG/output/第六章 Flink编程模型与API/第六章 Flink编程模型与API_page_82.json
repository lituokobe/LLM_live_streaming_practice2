[{"bbox": [126, 103, 753, 184], "category": "Text", "text": "```groovy\n//必须设置checkpoint,否则数据不能写入mysql\nenv.enableCheckpointing(5000)\n```"}, {"bbox": [126, 232, 1423, 734], "category": "Text", "text": "```groovy\n/**\n * Socket中输入数据如下:\n * 001,186,187,fail,1000,10\n * 002,186,187,success,2000,20\n * 003,187,188,fail,3000,30\n * 004,187,188,fail,4000,40\n */\nval ds: DataStream[StationLog] = env.socketTextStream(\"node5\", 9999)\n.map(line => {\n    val arr: Array String] = line.split(\",\")\n    StationLog(arr(0).trim, arr(1).trim, arr(2).trim, arr(3).trim, arr(4).trim.toLong, arr(5).trim.toLong)\n})\n```"}, {"bbox": [126, 783, 1565, 949], "category": "Text", "text": "```groovy\n//设置 被叫号码为key\nds.keyBy(_.callIn).process(new KeyedProcessFunction [String,StationLog,String] {\n    //定义一个状态,记录上次通话时间\n    lazy val timeState = getRuntimeContext state (new ValueStateDescriptor [Long] \"time\", classOf [Long])\n```"}, {"bbox": [142, 1037, 1602, 1797], "category": "Text", "text": "```groovy\n//每条数据都会调用一次\noverride def processElement(value: StationLog, ctx: KeyedProcessFunction [String, StationLog, String] #Context\n    //获取当前key对应的状态\n    val time: Long = timeState.value()\n\n    //如果该被叫手机号呼叫状态是fail且time为0,说明是第一条数据,注册定时器\n    if(\"fail\".equals(value callType) && time == 0) {\n        //获取当前时间\n        val nowTime: Long = ctx_TIMERService().currentProcessingTime()\n        //触发定时器时间为当前时间+5s\n        val onTime = nowTime + 5000\n\n        //注册定时器\n        ctx_TIMERService().registerProcessingTimeTimer(onTime)\n\n        //更新定时器\n        timeState.update(onTime)\n    }\n```"}, {"bbox": [159, 1845, 1271, 2095], "category": "Text", "text": "```groovy\n//如果该被叫手机号呼叫状态不是fail且time不为0,表示有呼叫成功了,可以取消触发器\nif(!value callType'.equals(\"fail\") && time!=0) {\n    //删除定时器\n    ctx_TIMERService().deleteProcessingTimeTimer(time)\n    //清空时间状态\n    timeState.clear()\n}\n```"}]