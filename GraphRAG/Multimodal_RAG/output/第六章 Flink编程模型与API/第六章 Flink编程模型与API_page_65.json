[{"bbox": [122, 97, 584, 186], "category": "Text", "text": "ds shuffle print().setParallelism(3)\nenv.execute()"}, {"bbox": [107, 233, 1575, 331], "category": "Text", "text": "注意:以上无论是java代码还是scala代码多次执行时,在socket中输入相同数据集,每次执行的结果可以看出相同数据随机由不同的线程进行处理。"}, {"bbox": [110, 379, 637, 443], "category": "Title", "text": "### 6.7.3 rebalance轮询分区"}, {"bbox": [107, 474, 1589, 623], "category": "Text", "text": "在Flink中可以对oriDataStream调用rebalance方法来使用rebalance partitioner分区策略对数据进行轮询重分区,这种分区方式采用RoundRobin负载均衡算法保证每个分区的数据平衡,当数据出现倾斜时可以使用这种分区策略对数据进行重分区。"}, {"bbox": [128, 716, 1559, 1193], "category": "Picture"}, {"bbox": [107, 1245, 1150, 1381], "category": "Text", "text": "**注意:**\n1) Flink中改变并行度默认采用的就是rebalance partitioner分区策略。"}, {"bbox": [107, 1412, 1561, 1507], "category": "Text", "text": "2) rebalance partitioner分区策略会对数据全局性的通过网络传输实现数据轮询重分区,网络开销大。"}, {"bbox": [128, 1546, 393, 1593], "category": "Text", "text": "* **Java代码实现**"}, {"bbox": [122, 1640, 1411, 1856], "category": "Text", "text": "StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\nenv.setParallelism(1);\noriDataStream&lt;String&gt; source = env.socketTextStream(\"node5\", 9999);\nsource.rebalance().print(\"shuffle\").setParallelism(3);\nenv.execute();"}, {"bbox": [130, 1902, 406, 1951], "category": "Text", "text": "* **Scala代码实现**"}, {"bbox": [122, 2000, 1440, 2084], "category": "Text", "text": "val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment\nenv.setParallelism(1)"}]