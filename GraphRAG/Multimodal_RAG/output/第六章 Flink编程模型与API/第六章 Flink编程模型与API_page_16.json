[{"bbox": [118, 139, 1476, 830], "category": "Text", "text": "```groovy\n//当取消对应的Flink任务时被调用\noverride def cancel(): Unit = {\n    flag = false\n}\n\nobject NoParallelSource {\n    def main(args: Array String): Unit = {\n        val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment\n        import org.apache.flink api Playful._\n        val ds: DataStream[StationLog] = env.addSource(new MyDefinedNoParallelSource)\n        ds.print()\n        env.execute()\n    }\n}\n```"}, {"bbox": [107, 881, 883, 943], "category": "Title", "text": "### 6.3.5.2 ParallelSourceFunction接口实现"}, {"bbox": [107, 972, 1575, 1022], "category": "Text", "text": "实现ParallelSourceFunction 接口实现有并行度的自定义Source, Java代码和Scala代码分别如下:"}, {"bbox": [128, 1053, 325, 1104], "category": "Text", "text": "* Java代码"}, {"bbox": [120, 1148, 1236, 2097], "category": "Text", "text": "```java\n/**\n * Flink读取自定义有并行度的Source,自定义Source实现 ParallelSourceFunction\n */\nclass MyDefinedParallelSource implements ParallelSourceFunction<StationLog> {\n    Boolean flag = true;\n\n    /**\n     * 主要方法:启动一个Source,大部分情况下都需要在run方法中实现一个循环产生数据\n     * 这里计划1s 产生1条基站数据,由于是并行,当前节点有几个core就会有几条数据\n     */\n    @Override\n    public void run(SourceContext<StationLog> ctx) throws Exception {\n        Random random = new Random();\n        String[] callTypes = {\"fail\", \"success\", \"busy\", \"barring\"};\n        while flag{\n            String sid = \"sid_\" + random.nextInt(10);\n            String callOut = \"1811234\" + (random.nextInt(9000)+1000);\n            String callIn = \"1915678\" + (random.nextInt(9000)+1000);\n            String callType = callTypesrand.nextInt(4);\n            Long callTime = System.currentTimeMillis();\n            Long durations = Long.valueOf(random.nextInt(50) + \"\");\n            ctx.collect(new StationLog sid, callOut, callIn, callType, callTime, durations));\n```"}]