[{"bbox": [121, 99, 1528, 827], "category": "Text", "text": "```java\n    @Override\n    public void cancel() {\n        flag = false;\n    }\n}\n\n/**\n * Flink读取自定义Source，并行度为1\n */\npublic class NoParallelSource {\n    public static void main(String[] args) throws Exception {\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        DataStreamSource<StationLog> dataStream = env.addSource(new MyDefinedNoParallelSource());\n        dataStream.print();\n        env.execute();\n    }\n}\n```"}, {"bbox": [135, 874, 353, 916], "category": "Title", "text": "## Scala 代码"}, {"bbox": [121, 968, 1236, 2077], "category": "Text", "text": "```scala\n/**\n * Flink读取自定义Source，并行度为1\n */\nclass MyDefinedNoParallelSource extends SourceFunction[StationLog] {\n    var flag = true\n\n/**\n * 主要方法:启动一个Source,大部分情况下都需要在run方法中实现一个循环产生数据\n * 这里计划每次产生10条基站数据\n */\noverride def run(ctx: SourceFunction SourceContext[StationLog]): Unit = {\n    val random = new Random()\n    val callTypes = Array[String](\"fail\", \"success\", \"busy\", \"barring\")\n\n    while (flag) {\n        val sid = \"sid_\" + random.nextInt(10)\n        val callOut = \"1811234\" + (random.nextInt(9000) + 1000)\n        val callIn = \"1915678\" + (random.nextInt(9000) + 1000)\n        val callType = callTypes(random.nextInt(4))\n        val callTime = System.currentTimeMillis()\n        val durations = random.nextInt(50).toLong\n        ctx.collect(StationLog sid, callOut, callIn, callType, callTime, durations))\n    }\n    Thread.sleep(1000) //每条数据暂停1s\n}\n```"}]