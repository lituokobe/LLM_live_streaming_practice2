[{"bbox": [126, 118, 1572, 280], "category": "List-item", "text": "* 通过实现SourceFunction接口来自定义无并行度（也就是并行度只能为1）的Source。\n* 通过实现ParallelSourceFunction 接口或者继承RichParallelSourceFunction 来自定义有并行度的数据源。"}, {"bbox": [108, 312, 879, 364], "category": "Text", "text": "无论是那种接口实现方式都需要重写以下两个方法："}, {"bbox": [126, 394, 1559, 556], "category": "List-item", "text": "1. run():大部分情况下都需要在run方法中实现一个循环产生数据,通过Flink上下文对象传递到下游。\n2. cancel():当取消对应的Flink任务时被调用。"}, {"bbox": [108, 601, 741, 661], "category": "Title", "text": "### 6.3.5.1 SourceFunction接口实现"}, {"bbox": [108, 691, 1453, 741], "category": "Text", "text": "实现SourceFunction 接口实现无并行度的自定义Source,java代码和Scala代码分别如下："}, {"bbox": [126, 772, 326, 823], "category": "List-item", "text": "* Java代码"}, {"bbox": [123, 870, 1250, 2065], "category": "Text", "text": "```java\n/**\n * 自定义非并行Source\n*/\nclass MyDefinedNoParallelSource implements SourceFunction<StationLog> {\n    Boolean flag = true;\n\n/**\n * 主要方法:启动一个Source,大部分情况下都需要在run方法中实现一个循环产生数据\n * 这里计划每秒产生1条基站数据\n*/\n@Override\npublic void run(SourceContext<StationLog> ctx) throws Exception {\n    Random random = new Random();\n    String[] callTypes = {\"fail\", \"success\", \"busy\", \"barring\"};\n    while flag{\n        String sid = \"sid_\" + random.nextInt(10);\n        String callOut = \"1811234\" + (random.nextInt(9000) + 1000);\n        String callIn = \"1915678\" + (random.nextInt(9000) + 1000);\n        String callType = callTypesrand.nextInt(4);\n        Long callTime = System.currentTimeMillis();\n        Long durations = Long.valueOf(random.nextInt(50) + \"\");\n        ctx.collect(new StationLog sid, callOut, callIn, callType, callTime, durations));\n        Thread.sleep(1000); //1s 产生一个事件\n    }\n}\n\n//当取消对应的Flink任务时被调用\n```"}]