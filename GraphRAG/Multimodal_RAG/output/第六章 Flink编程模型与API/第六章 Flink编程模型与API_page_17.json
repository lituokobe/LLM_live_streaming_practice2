[{"bbox": [122, 97, 1487, 951], "category": "Text", "text": "```java\nThread.sleep(1000); //1s 产生一个事件\n}\n}\n\n//当取消对应的Flink任务时被调用\n@Override\npublic void cancel() {\n    flag = false;\n}\n}\n\npublic class ParallelSource {\n    public static void main(String[] args) throws Exception {\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        DataStreamSource<StationLog> dataStream = env.addSource(new MyDefinedParallelSource());\n        dataStream.print();\n        env.execute();\n    }\n}\n```"}, {"bbox": [132, 999, 346, 1047], "category": "Title", "text": "## • Scala代码"}, {"bbox": [122, 1093, 1236, 2034], "category": "Text", "text": "```java\n/**\n * Flink读取自定义有并行度的Source,自定义Source实现 ParallelSourceFunction\n */\nclass MyDefinedParallelSource extends ParallelSourceFunction[StationLog] {\n    var flag = true\n\n/**\n * 主要方法:启动一个Source,大部分情况下都需要在run方法中实现一个循环产生数据\n * 这里计划每次产生10条基站数据\n */\noverride def run(ctx: SourceContext[StationLog]): Unit = {\n    val random = new Random()\n    val callTypes = Array String](\"fail\", \"success\", \"busy\", \"barring\")\n\n    while (flag) {\n        val sid = \"sid_\" + random.nextInt(10)\n        val callOut = \"1811234\" + (random.nextInt(9000) + 1000)\n        val callIn = \"1915678\" + (random.nextInt(9000) + 1000)\n        val callType = callTypes(random.nextInt(4))\n        val callTime = System.currentTimeMillis()\n        val durations = random.nextInt(50).toLong\n        ctx.collect(StationLog sid, callOut, callIn, callType, callTime, durations))\n    }\n}\n```"}]