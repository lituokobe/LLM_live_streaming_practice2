[{"bbox": [118, 121, 1607, 254], "category": "Text", "text": "```java\npublic void onTimer(long timestamp, ProcessFunction<对象类型, 返回对象类型, >.OnTimerContext ctx, Collector<...>\n}\n```"}, {"bbox": [110, 298, 1574, 448], "category": "Text", "text": "onTimer()方法有三个参数:时间戳(timestamp)、上下文(ctx)和收集器(out)。\ntimestamp 是设定好的触发时间,通常与水位线(watermark)相关。方法中可以使用上下文和收集器执行相应的操作,包括使用定时服务(TimerService)和输出处理后的数据。"}, {"bbox": [108, 481, 1585, 682], "category": "Text", "text": "总而言之,Flink 的 ProcessFunction 提供了强大的灵活性,可以实现各种自定义的业务逻辑,可以实现各种基本转换操作,如 flatMap、map 和 filter,通过获取上下文的方法还可以自定义状态进行聚合操作。同时,ProcessFunction 也支持定时触发操作,可以根据时间来分组数据,并在指定的时间触发计算和输出结果,实现窗口 window的功能。"}, {"bbox": [108, 714, 1583, 814], "category": "Text", "text": "**案例:** Flink读取Socket中通话数据,如果被叫手机连续5s呼叫失败生成告警信息。(注意:该案例涉及到状态编程,这里我们只需要了解状态意思即可,后续章节会详细讲解状态)"}, {"bbox": [132, 848, 390, 895], "category": "Title", "text": "## Java代码实现"}, {"bbox": [120, 941, 1479, 2096], "category": "Text", "text": "```java\nStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n//必须设置checkpoint,否则数据不能正常写出到mysql\nenv.enableCheckpointing(5000);\n/*\n * socket 中输入数据如下:\n * 001,186,187,fail,1000,10\n * 002,186,187,success,2000,20\n * 003,187,188,fail,3000,30\n * 004,187,188,fail,4000,40\n * 005,188,187,busy,5000,50\n */\nSingleOutputStreamOperator<StationLog> ds = env.socketTextStream(\"node5\", 9999)\n    .map(one -> {\n        String[] arr = one.split(\",\");\n        return new StationLog(arr[0], arr[1], arr[2], arr[3], Long.valueOf(arr[4]), Long.valueOf(arr[5]));\n    });\n\n//按照被叫号码分组\nKeyedStream<StationLog, String> keyedStream = ds.keyBystationLog -> stationLog.getCallIn());\n\n//使用ProcessFunction实现通话时长超过5秒的告警\nkeyedStream.process(new KeyedProcessFunction<String, StationLog, String>() {\n    //使用状态记录上一次通话时间\n    ValueState(Long) timeState = null;\n\n    //在open方法中初始化记录时间的状态\n```"}]