[{"bbox": [120, 100, 703, 400], "category": "Text", "text": "```java\nisRunning = false\n}\n})\n\nds.rescale.print(\"rescale\").setParallelism(4)\nenv.execute()\n```"}, {"bbox": [109, 447, 1561, 545], "category": "Text", "text": "注意：以上java或者scala代码可以测试rebalance和rescale方法的异同，两者都是轮询往下游发送数据，区别是rebalance是全局方式发送，rescale是局部方式发送。"}, {"bbox": [109, 593, 640, 656], "category": "Section-header", "text": "## 6.7.5 broadcast广播分区"}, {"bbox": [109, 686, 1584, 889], "category": "Text", "text": "在Flink中可以对oriDataStream调用broadcast方法使用broadcast partitioner分区策略将数据流数据复制广播到下游算子各个并行task中，下游算子task可以直接从本地内存中获取广播数据集使用，不再依赖网络传输数据流数据。broadcast partitioner 分区策略适合于小数据集广播，例如，当大数据集关联小数据集时，可以通过广播小数据集方式将数据分发到算子的每个分区中。"}, {"bbox": [120, 983, 1549, 1516], "category": "Picture"}, {"bbox": [109, 1584, 1490, 1686], "category": "Text", "text": "注意：oriDataStream 通过broadcast广播后，数据被广播到每个TaskManager的内存中，每个TaskManager节点上的task都可以从节点内存中获取该广播数据。"}, {"bbox": [109, 1717, 1569, 1816], "category": "Text", "text": "案例：读取Socket中学生分数信息作为主流，将学生信息流作为广播流进行广播，然后两者进行关联获取学员全部信息。"}, {"bbox": [134, 1850, 389, 1899], "category": "Section-header", "text": "* **Java代码实现**"}, {"bbox": [123, 1948, 1606, 2078], "category": "Text", "text": "```java\nStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n//用户分数信息\nSingleOutputStreamOperator[Tuple2<String, Integer>> mainDS = env.socketTextStream(\"node5\", 9999).map\n```"}]